# 第七周总结

## 排序算法

### 一、选择排序：

### 通过每次对未排序序列的选择实现从未排序序列中选择出符合顺序规则的元素放到已排序序列中。

1、算法步骤：

（1）在整个排序序列中找到最小（最大）元素存放到排序序列的起始位置

（2）再从剩余未排序元素中继续寻找最小（最大）元素，放到已排序序列的末尾

（3）重复步骤（2），直到所有元素均排序完毕

2、实现：基于比较，通过依次寻找待排序序列中的最小（最大）元素放到已排序序列中

```
`void SeleectSort(int a[],int n)`
`{`
    `int i,j;`
    `for(i=0;i<n-1;i++)//外层（n-1）次比较`
    `{`
        `int min=i;//标记未排序序列的第一个元素为当前序列的最小值`
        `for(j=i+1;j<n;j++)//遍历未排序数组，内层（n-i）次比较`
        `{`
            `if(a[j]<a[min])//找到目前的最小值`
            `{`
                `min=j;//记录最小值元素的下标`
            `}`
        `}`
        `swap(&a[min],&a[j]);//交换两个元素的值`
    `}`
`}`
```



```
void swap(int *a,int *b)//交换两个变量的值
{
    int temp=*a;
    *a=*b;
    *b=temp;
}
```

3、算法分析

时间复杂度：O(n*n)

空间复杂度：O(n)，仅在每次交换时需要一个存储空间

###  二、冒泡排序：从前向后扫描，依次比较相邻两个元素，若前者大，则交换位置，每一趟下来，最大的元素必在最后的位置。

本质问题：有多少个逆序对，就需要交换多少次，每次只能消除一个逆序对

1、算法步骤

（1）从序列中的第一个元素开始，依次比较相邻的两个元素，如果两个元素的排列不满足排序规则，则将这两个元素的位置交换，直到序列中最后一对元素比较完毕（每次遍历会找到排序后序列中的最后一个元素）

（2）重复步骤（1），直到没有任何一对元素需要比较（每次都从序列开头开始）

2、实现

```
void BubbleSort(int a[],int n)
{
    int i,j;
    for(i=0;i<n-1;i++)//外层循环，第几趟比较，注意变量的范围
    {
        for(j=0;j<n-i-1;j++)//内层循环，与剩下的元素比较，后面的i个元素已排好序，注意变量的范围
        {
            if(a[j]>a[j+1])
            {
                swap(&a[j],&a[j+1]);//将值较大的元素放到后面
            }
        }
    }
}
```

3、分析

时间复杂度：O(n*n)

空间复杂度：O(n*n)，仅在每次交换时需要一个存储空间

### 三、插入排序：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

1、算法步骤

（1）将待排序序列中的第一个元素看做一个有序序列（第一个元素默认有序），把第二个元素到最后一个元素当成未排序序列

（2）从头到尾扫描未排序序列，将每个元素与有序序列中的元素比较，并放入适当的位置（相等的元素不改变元素在原序列中的相对位置）

2、实现

```
void InsertSort(int a[],int n)
{
    int i,j;
    int temp;
    for(i=1;i<n;i++)//遍历未排序中的每一个元素（待排序序列中第一个元素默认有序）
    {
        temp=a[i];
        for(j=i;j>0 && temp< a[j-1];j--)//依次将未排序序列a[1]~a[n]中的元素与已排序序列中的元素a[0]~a[i]进行比较，直到找到一个逆序数或者与有排序的全部元素比较完毕
        {
            a[j]=a[j-1];//交换
        }
        a[j]=temp;//此时的j为for循环结束后的j-1
    }
}
```

3、分析

时间复杂度：O(n*n)

空间复杂度：O(n)，虽然需要多次交换，但是仅在n次交换中需要临时的存储空间

### 四、希尔排序（递减增量排序算法）:通过比较相距一定间隔的元素来工作，各趟比较所用的距离随着算法的进行而减小

先将整个待排序的记录序列分割为若干个子序列分别进行直接插入排序，带整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序。

1、算法步骤

（1）选择一个递减的增量序列h1,h2,.....ht，按增量序列个数t，对序列进行k趟排序

（2）每趟排序，根据对应的增量hk,将待排序序列分割成hk组，然后分别对每组的组内元素进行直接插入排序

（3）重复步骤（2）,直到增量值hk=1时，对整个序列进行直接插入排序

2、实现

```
void ShellSort(int a[],int n)
{
    int i,j,increment;
    int temp;
    for(increment=n/2;increment>0;increment/=2)//设置增量序列的值
    {
        for(i=increment;i<n;i++)//先找到每组的中间元素，i++保证一组内后面的元素也会被比较到
        {
            temp=a[i];
            for(j=i;j>=increment;j-=increment)//比较同组元素，组内相邻元素的间隔为increment
            {
                if(temp<a[j-increment])//组内元素之间依次比较大小
                    a[j]=a[j-increment];
                else
                    break;
            }
            a[j]=temp;
        }
    }
}
```

3、分析：

时间复杂度：Θ（n*n）

空间复杂度：O(n*n)，虽然需要多次交换，但是仅在n次交换中需要临时的存储空间

### 五、堆排序：利用数据结构（堆---具有堆序性的特殊二叉树）的特性完成排序

1、算法步骤

（1）为待排序的元素序列建立一个二叉堆（大根堆或小根堆）

​        大根堆：根节点的元素值最大

​        小根堆：根节点的元素值最小

（2）由于建立的二叉堆的堆序特性，在根节点处可以直接得到待排序序列元素中的最小值或最大值，所以通过依次删除二叉堆的根节点可以得到排序后的序列。

使用大根堆：得到的是按升序排列的元素

使用小根堆：得到的是按降序排列的元素

（3）具体做法：

①交换堆中根节点的元素值与最后一个节点的元素值

②缩小堆大小，即断开堆与最后一个节点的连接

③根据堆序性，对新的根节点进行下滤操作（根节点删除，自上而下，依次寻找子节点中值较小者作为根节点，直到将原完全二插树中的最后一个元素放到合适的位置）

2、实现

```
void PercDown(int a[],int i,int n)//下滤
{
    int child;
    int temp;
    for(temp=a[i];LeftChild(i)<n;i=child)//依次找孩子，直到孩子为堆中的最后一个节点
    {
        child=LeftChild(i);//更新孩子节点的位置
        if(child!=n-1 && a[child+1]>a[child])//如果左孩子不是堆中最后的一个并且右孩子的值比左孩子的值大
            child=child+1;//更新孩子的位置为右孩子所在的位置，即寻找左右孩子中较小的那个
        if(temp<a[child])
            a[i]=a[child];//如果父节点的元素值小于子节点元素值，则更新父节点的值为子节点的值
        else
            break;
    }
    a[i]=temp;//更新位置i上的元素值
}
void HeapSort(int a[],int n)//堆排序
{
    int i;
    for(i=n/2;i>=0;i--)
        PercDown(a,i,n);//构建二叉堆
    for(i=n-1;i>0;i--)
    {
        swap(&a[0],&a[i]);//交换根节点和最后一个节点的值
        PercDown(a,0,i);//对根节点进行下滤操作
    }
}
```

3、算法分析

时间复杂度：O(NlogN)

空间复杂度：需要临时存储空间辅助进行比较和交换操作

### 六、归并排序：利用分治法的思想，将待排序序列分割成子序列分别进行排序，然后依次将排好序的两个序列进行两两合并。

1、算法步骤

（1）创建临时数组用于对两个有序序列的归并操作

（2）递归地进行对序列分割排序，两两有序合并的工作（递归的出口为序列中只有一个元素的情况），并将排序的结果保存在临时数组中

（3）将临时数组中排序后的结果拷贝到原数组中，即实现原序列排序的效果

2、实现

```
void Merge(int a[],int temp[],int Lpos,int Rpos,int RightEnd)//归并两个有序序列
{
    int i,LeftEnd,NumElements,tempPos;
    LeftEnd=Rpos-1;//左子序列的结束位置
    tempPos=Lpos;//临时数组的开始位置
    NumElements=RightEnd-Lpos+1;//根据元素的起始和结束位置计算元素的个数
    while(Lpos<=LeftEnd && Rpos<=RightEnd)//当两个序列中元素的位置都未到达序列的结束位置
    {
        if(a[Lpos]<=a[Rpos])//当前要合并的两个子序列中元素位置未出现交叉，且左子序列的元素值小于右子序列的元素值
            temp[tempPos++]=a[Lpos++];//将左子序列中当前指示的元素放到临时数组中
        else
            temp[tempPos++]=a[Rpos++];//将右子序列中当前指示的元素放到临时数组中
    }
    while(Lpos<=LeftEnd)//当右子序列中所指示的元素位置到达右子序列的结尾时，将左子序列中剩下的元素按顺序拷贝到临时数组中
        temp[tempPos]=a[Lpos++];
    while(Rpos<=RightEnd)//当左子序列中所指示的元素位置到达左子序列的结尾时，将右子序列中剩下的元素按顺序拷贝到临时数组中
        temp[tempPos]=a[Rpos++];
    for(i=0;i<NumElements;i++,RightEnd--)
    {
        a[RightEnd]=temp[RightEnd];//将排序后的临时数组中的各个元素拷贝到原数组中
    }
}
void MSort(int a[],int temp[],int Left,int Right)//归并排序
{
    int center;
    if(Left < Right)
    {
        center=(Left+Right)/2;
        MSort(a,temp,Left,center);//递归的将原序列分割成两个子序列
        MSort(a,temp,center+1,Right);
        Merge(a,temp,Left,center+1,Right);//将分割的两个子序列归并
    }
}
void MergeSort(int a[],int n)
{
    int *temp;
    temp=malloc(n*sizeof(int));//申请临时存储空间
    if(temp!=NULL)
    {
        MSort(a,temp,0,n-1);//对维度为n的数组进行归并排序，左边从下标为0处开始，右边到下标n-1处结束
        free(temp);
    }
    else
        printf("No space for temp array!");
}
```

3、分析

时间复杂度：O(NlogN)

空间复杂度：需要复杂数组存储中间的排序结果

### 七、快速排序

1、算法步骤

（1）选区枢纽元：三数（序列左端、序列右端、序列中心位置）中值分割法

（2）分割排序序列：将枢纽元通过与序列最后位置的元素交换放到序列的最后；然后同时从前面和后面（枢纽元前面的元素所在的位置）开始扫描序列中的每一个元素，分别比较当前扫描到的两个元素的值与枢纽元的值的大小，将所有小于枢纽元的元素放到数组的左边，将所有大于枢纽元的元素放到数组的右边。如果左边遇到大于等于枢纽元的元素则停止，右边遇到小于等于枢纽元的元素值则停止，当两边均停止时则交换左右两边元素的位置。然后继续扫描，直到两边指示的元素位置交错位置。最后，将枢纽元与扫描完左边标识所指示的元素进行交换。

（3）递归地对分割的序列内部进行排序，然后将以枢纽元为中心的子序列进行合并操作。

2、实现

```
int Division(int a[],int Left,int Right)//三数中值分割寻找枢纽元
{
    int center=(Left+Right)/2;//找序列中心位置
    if(a[Left]>a[center])   //依次比较序列左端、中心位置、右端元素的大小，交换不符合从小到大排列的元素
        swap(&a[Left],&a[center]);
    if(a[Left]>a[Right])
        swap(&a[Left],&a[Right]);
    if(a[Right]< a[center])
        swap(&a[Right],&a[center]);

    swap(&a[center],&a[Right-1]);//选取中心位置处的元素作为枢纽元
    return a[Right-1];//返回枢纽元的大小

}
void QuickSort(int a[],int Left,int Right)//快速排序
{
    int i,j;
    int P;//标记枢纽元的大小
    if(Left+Cutoff <= Right)//判断数组中元素的个数是否符合快速排序的容量要求，当数组中元素个数小于3时，通过Division后就已经有序
    {
        P=Division(a,Left,Right);
        i=Left;
        j=Right-1;
        for( ; ; )
        {
            while(a[++i]<P) {}//左边标记元素的值小于枢纽元时，不做任何操作
            while(a[--j]>P) {}//右边标记元素的值大于枢纽元时，不做任何操作
            if(i<j)//当未出现交错时，且左边标记的元素值大于枢纽元且右边标记的元素值小于枢纽元时，交换两个元素的位置
                swap(&a[i],&a[j]);
            else
                break;//否则，跳出循环
        }
        swap(&a[i],&a[Right-1]);//将枢纽元的位置与左端标记停止的位置交换
        QuickSort(a,Left,i-1);//递归的对左边部分进行快速排序
        QuickSort(a,i+1,Right);//递归的对右边部分进行快速排序
    }
    else
        return;
}
```

3、分析

时间复杂度：O(NlogN)

空间复杂度：仅在每次交换时需要一个存储空间